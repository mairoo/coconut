# Keycloak 인증과 백엔드 권한 관리 설계

## 개요

Spring Security와 Keycloak을 연동하여 JWT 기반 인증을 구현하면서, 복잡한 역할(Role)과 그룹(Group) 관리를 백엔드에서 처리하는 아키텍처 설계

## 시스템 역할 분담

### Keycloak

- **액세스/리프레시 토큰 관리**
- JWT 발급 및 서명 검증
- 사용자 인증 (로그인/로그아웃)
- OpenID Connect 프로토콜 지원

### 백엔드 (Spring Security)

- **역할(Role) 관리**
- **그룹(Group) 관리**
- `@PreAuthorize`, `@HasRole` 등으로 세밀한 권한 제어
- 복잡한 비즈니스 로직에 따른 권한 처리

### 설계 근거

비즈니스 로직에서 역할과 그룹이 수평한 구조 또는 일대일 매핑 정도의 복잡도이면 Keycloak에서 관리해도 문제없지만, **역할과 그룹이 수직적 계층을 가지거나 복잡한 상속 관계**를 가질 경우 Keycloak에서
유지보수 관리하기 어렵다.

## JWT 클레임에 roles, group 포함 방법 비교

### 방법 1: Keycloak User Attributes 설정

#### 장점

- **성능 향상**: 백엔드 DB 조회 없이 JWT에서 직접 권한 정보 획득
- **일관성**: 토큰에 모든 필요 정보 포함
- **확장성**: 새로운 클레임 쉽게 추가 가능
- **분산 캐싱**: JWT 자체가 분산 캐시 역할

#### 단점: 복잡한 동기화 이슈

- **사용자 생성 시**: 백엔드에서 사용자 생성 시 Keycloak 속성도 자동 설정 필요
- **역할 변경 시**: DB 변경 시 Keycloak 속성도 이벤트 기반 자동 업데이트 필요
- **배치 동기화**: 주기적으로 모든 사용자 정보 동기화 필요
- **초기 마이그레이션**: 기존 사용자들을 일괄적으로 Keycloak에 동기화
- **그룹/역할 정의 변경**: 역할과 그룹 자체가 변경될 때 모든 사용자 일괄 동기화 문제
- **장애 복구**: Keycloak 장애 시 동기화 실패 복구 메커니즘 필요
- **데이터 일관성**: 두 시스템 간 데이터 불일치 위험

### 방법 2: 백엔드 Redis 캐싱

#### 장점

- **단일 책임**: 백엔드 DB가 유일한 권한 정보 소스 (Single Source of Truth)
- **장애 격리**: Keycloak 문제가 권한 시스템에 영향 없음
- **즉시 반영**: 역할 변경 시 캐시만 무효화하면 즉시 적용
- **디버깅 용이**: 문제 발생 시 DB만 확인하면 됨
- **점진적 최적화**: 필요에 따라 캐싱 전략만 교체 가능

#### 캐싱 지점 옵션

1. **JWT Authentication Converter 내부 캐싱**
2. **UserRepositoryImpl 내부 캐싱**: 나중에 캐싱 전략 변경 시에도 Converter에 부작용 없음 ✅

## 성능 비교 분석

### 현재 상황 (매번 DB 조회)

- JWT 인증당: **~100ms** (쿼리 2번)
- 동시 사용자 100명 시: DB 부하 심각
- 확장성: 사용자 증가에 따라 선형적 부하 증가

### 방법 1 (Keycloak 동기화)

- JWT 인증당: **~1ms**
- 최고 성능이지만 동기화 복잡도와 장애 위험 높음
- 개발/운영 비용: 매우 높음

### 방법 2 (Redis 캐싱)

- 캐시 히트 시: **~1ms** (90%+ 케이스)
- 캐시 미스 시: **~110ms** (10%- 케이스)
- **평균: ~10ms (90% 성능 향상)**
- 개발/운영 비용: 적정 수준

## DDD 구조에 따른 쿼리 최적화 제약

### 왜 쿼리 2번이 불가피한가?

1. **DDD 레이어 분리**: Entity ↔ Domain Model 매핑 필요
2. **N+1 방지**: UserRoleEntity를 별도 쿼리로 조회
3. **QueryDSL 구조**: 복잡한 JOIN보다 단순한 쿼리 2개가 더 명확
4. **관심사 분리**: User 조회와 Role 조회의 책임 분리

### 캐싱이 최적의 해결책인 이유

- **구조 변경 없음**: 기존 DDD 구조 유지
- **복잡도 증가 없음**: JOIN 쿼리로 복잡성 늘리지 않음
- **성능 효과 극대화**: 쿼리 2번 → 0번 (캐시 히트 시)
- **확장성**: User ↔ Group 다대다 관계 시 효과 더욱 극대화

## 의사결정 기준 및 근거

### 우선순위

1. **시스템 안정성** > 성능 최적화
2. **유지보수성** > 개발 속도
3. **데이터 일관성** > 분산 시스템 복잡도

### 방법 2 선택 이유

> **"동기화로 발생할 수 있는 부작용이 배보다 배꼽이 더 큰 상황"**

- Keycloak 장애가 권한 시스템에 영향 없음
- 단일 책임: 백엔드 DB가 유일한 권한 정보 소스
- 점진적 개선: 캐싱 전략만 교체 가능
- 복잡성 대비 효과: 90% 성능 향상으로 충분

## 확장 시나리오 대응

### User ↔ Group 다대다 관계 시

- **쿼리 수**: 2개 → 4개로 증가
- **캐싱 효과**: 더욱 극대화 (4개 → 0개)
- **동기화 방식**: 복잡도 기하급수적 증가
- **백엔드 방식**: 동일한 캐싱 전략으로 대응 가능

### 계층적 권한 구조 시

- **Keycloak 방식**: 표현의 한계, JWT 크기 증가
- **백엔드 방식**: 복잡한 비즈니스 로직 자유롭게 구현 가능

## 최종 구현 설계

### UserRepositoryImpl 메서드 구조

```kotlin
// 범용 메서드 (캐싱 없음)
fun findUserWithRoles(criteria: UserSearchCriteria): User?

// JWT 인증 전용 캐시 메서드  
fun findUserWithRolesForAuth(email: String): User?
```

### 캐시 전략

- **캐시 키**: `auth:user:{email}`
- **TTL**: 30분
- **무효화**: 사용자 역할/그룹 변경 시 즉시
- **Fallback**: Redis 장애 시 DB로 자동 전환

### 아키텍처 흐름

1. **JWT 수신** → Keycloak 서명 검증
2. **이메일 추출** → 캐시 조회 시도
3. **캐시 히트** → 즉시 권한 반환
4. **캐시 미스** → DB 조회 → 캐시 저장 → 권한 반환

## 리스크 관리 및 모니터링

### 주요 리스크

- **Redis 장애**: 성능 저하 (하지만 서비스 중단 없음)
- **캐시 무효화 타이밍**: 권한 변경 후 일시적 불일치 가능성
- **메모리 사용량**: 사용자 증가에 따른 Redis 메모리 관리

### 모니터링 포인트

- **캐시 히트율**: 목표 90% 이상
- **JWT 인증 응답시간**: 목표 평균 10ms 이하
- **권한 변경 후 반영 지연시간**: 목표 1초 이내
- **Redis 메모리 사용률**: 임계치 80% 미만

### 알림 임계값

- 캐시 히트율 80% 미만 시 알림
- JWT 인증 평균 응답시간 50ms 초과 시 알림
- Redis 장애 시 즉시 알림

## 결론

**백엔드 Redis 캐싱 방식**을 채택하여 성능과 안정성의 최적 균형점을 확보합니다. 90%의 성능 향상을 달성하면서도 시스템 복잡도는 최소화하고, 향후 확장성과 유지보수성을 모두 보장